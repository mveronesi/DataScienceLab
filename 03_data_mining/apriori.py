import json
from timeit import timeit
from mlxtend import frequent_patterns

def find_items(dataset):
    """Given a dataset of transactions return all possible values.
    
    Input: dataset, a list of tuples representing transactions
    Output: a tuple of all possible items ordered lexicographically
    """
    items = set()
    for t in dataset:
        for item in t:
            items.add(item)
    items = list(items)
    items.sort()
    return tuple(items)

def contain(subset, superset):
    """Return True iff subset is contained in superset
    
    Input: subset, a tuple of values
           superset, a tuple of values
    Output: True iff superset contains subset, false otherwise
    """
    result = True
    for item in subset:
        if item not in superset:
            result = False
            break
    return result


def support(itemset, dataset):
    """Return the support value of a given itemset among a given dataset

    Input: itemset, a tuple of string values;
           dataset, a list of tuples of string values
    Output: a float number representing the support value
    """
    num = 0.0
    for item in dataset:
        num += 1 if contain(itemset, item) else 0
    den = float(len(dataset))
    return num / den

def check_prefix(t1, t2, length):
    """Check if 2 structures t1 and t2 has the same prefix of a specified length.

    Input: - t1 & t2: two ordered structures of the same length
           - length: the prefix length to check
    Output: true iff t1 and t2 have the same prefix, false otherwise.
    """
    if len(t1) != len(t2) or len(t1) < length:
        print("ERROR")
        return False
    if length == 0:
        return True
    for i in range(length):
        if t1[i] != t2[i]:
            return False
    return True

def check_subsets(superset, itemsets):
    """Check if subsets of supersets generated by removing one of its element
    are contained in a set of itemsets

    Input: - superset: a data structure with objects
           - itemsets: a data structure of data structure of objects
    Output: True iff all subsets of superset generated removing one element at a time
    are included in itemsets, False otherwise.
    """
    for item in superset:
        tmp = list(superset)
        tmp.remove(item)
        tmp = tuple(tmp)
        if tmp not in itemsets:
            return False
    return True

def apriori(dataset, min_sup=0.5):
    """Apriori algorithm implementation for finding association rules.

    Input: dataset, the entire dataset as list of lists representing transactions;
           min_sup, float value representing the minimum support for result filtering.
    Output: a matrix with two columns:
    the first contain an itemset tuple, the second its support value.
    A row is present iff the value in the second column is >= min_sup.
    """
    result = [[], []]
    items = find_items(dataset) # tuple
    itemsets = [(i,) for i in items]
    for level in range(len(items)):
        if len(itemsets) == 0:
            break
        for i in itemsets:
            sup = support(i, dataset)
            if sup > min_sup:
                result[0].append(i)
                result[1].append(sup)
            else:
                itemsets.remove(i)

        new_itemsets = []
        for i in range(len(itemsets)-1):
            for j in range(i+1, len(itemsets)):
                if check_prefix(itemsets[i], itemsets[j], level) == True:
                    tmp = list(set(itemsets[i] + itemsets[j]))
                    tmp.sort()
                    tmp = tuple(tmp)
                    if check_subsets(tmp, itemsets):
                        new_itemsets.append(tmp)
                else:
                    break
                    
        itemsets = new_itemsets
    return result


# test dataset
"""
dataset = [
    ('a', 'b'),
    ('b', 'c', 'd'),
    ('a', 'c', 'd', 'e'),
    ('a', 'd', 'e'),
    ('a', 'b', 'c'),
    ('a', 'b', 'c', 'd'),
    ('b', 'c'),
    ('a', 'b', 'c'),
    ('a', 'b', 'd'),
    ('b', 'c', 'e')
]

res = apriori(dataset, 0.1)
for i in range(len(res[0])):
    print(res[0][i], " -> ", res[1][i])

"""
print("READING DATASET")
dataset = None
with open('../datasets/modified_coco.json') as f:
    dataset = json.load(f)

ds_elaborated = []
for row in dataset:
    tmp = tuple(row["annotations"])
    ds_elaborated.append(tmp)
print("DONE")

res = timeit(lambda: apriori(ds_elaborated, 0.02), number=1)
print(res)
#for i in range(len(res[0])):
#    print(res[0][i], " -> ", res[1][i])
